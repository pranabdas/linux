"use strict";(self.webpackChunklinux_tutorial=self.webpackChunklinux_tutorial||[]).push([[778],{3442:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>o,frontMatter:()=>c,metadata:()=>d,toc:()=>l});var s=r(4848),t=r(8453);const c={title:"Regular Expression"},i=void 0,d={id:"regex",title:"Regular Expression",description:"In order to demonstrate various examples, we will use a large text file",source:"@site/docs/regex.md",sourceDirName:".",slug:"/regex",permalink:"/linux/regex",draft:!1,unlisted:!1,editUrl:"https://github.com/pranabdas/linux/blob/main/docs/regex.md",tags:[],version:"current",frontMatter:{title:"Regular Expression"},sidebar:"docs",previous:{title:"Shell scripting",permalink:"/linux/shell-scripting"},next:{title:"Misc",permalink:"/linux/category/misc"}},a={},l=[{value:"Simple character match",id:"simple-character-match",level:3},{value:"Meta-characters",id:"meta-characters",level:3},{value:"Anchors",id:"anchors",level:3},{value:"Character class",id:"character-class",level:3},{value:"Word boundaries",id:"word-boundaries",level:3},{value:"Optional",id:"optional",level:3},{value:"Repetition",id:"repetition",level:3},{value:"Range quantifiers",id:"range-quantifiers",level:3},{value:"Grouping",id:"grouping",level:3},{value:"Resources",id:"resources",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In order to demonstrate various examples, we will use a large text file\n",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(4984).A+"",children:"A Room with a View by E. M. Forster"}),"\ndownloaded from ",(0,s.jsx)(n.a,{href:"https://www.gutenberg.org/cache/epub/2641/pg2641.txt",children:"Project Gutenberg"}),". We will use ",(0,s.jsx)(n.code,{children:"egrep"}),"\nprogram to find specific matches in the file. ",(0,s.jsx)(n.code,{children:"egrep"})," is ",(0,s.jsx)(n.code,{children:"grep -E"})," which allows\ninterpretation of pattern as extended regular expression. We will wrap our\nregular expression in ",(0,s.jsx)(n.code,{children:"'"})," (single quotes, they are not the part of the regular\nexpression) e.g.,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep '^cat' A_Room_with_a_View_by_E_M_Forster.txt\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, when regular expressions are processed by certain languages, we need\nto provide the regular expression enclosed between ",(0,s.jsx)(n.code,{children:"/"}),", they are not the part of\nregular expression but required by the parser to identify regex."]}),"\n",(0,s.jsx)(n.admonition,{title:"Good to know",type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"grep"})," (",(0,s.jsx)(n.code,{children:"g/re/p"}),") stands for Global Regular Expression Print."]})}),"\n",(0,s.jsx)(n.h3,{id:"simple-character-match",children:"Simple character match"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep 'cat' A_Room_with_a_View_by_E_M_Forster.txt\n"})}),"\n",(0,s.jsx)(n.p,{children:"It will match all instances of cat such as: delicate, indicated, catching,\nlocated etc."}),"\n",(0,s.jsx)(n.h3,{id:"meta-characters",children:"Meta-characters"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Wild card:"})," ",(0,s.jsx)(n.code,{children:"."})," (dot) is the wild card meta-character, it matches any\ncharacter including spaces except newline character. E.g., ",(0,s.jsx)(n.code,{children:"/h.t/"})," will match\nhot, hit, hat, that, with the, wish to ect. Similarly, ",(0,s.jsx)(n.code,{children:"/.a.a.a/"})," will match\nbanana or papaya."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Escape meta-character:"})," ",(0,s.jsx)(n.code,{children:"/9.00/"})," will match 9.00, 9500, 9:00. What do we do\nif we wanted to look for 9.00? Escape character comes to rescue: ",(0,s.jsx)(n.code,{children:"/9\\.00/"}),". In\ncase we want a literal back slash, we can use ",(0,s.jsx)(n.code,{children:"/\\\\/"}),". Do not use escape\ncharacter for characters that are not meta-character such as quotation marks.\nTab character: ",(0,s.jsx)(n.code,{children:"\\t"}),", newline: ",(0,s.jsx)(n.code,{children:"\\n"}),", ",(0,s.jsx)(n.code,{children:"\\r"})," or ",(0,s.jsx)(n.code,{children:"\\r\\n"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"anchors",children:"Anchors"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"Meta-character"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"^"})}),(0,s.jsx)(n.td,{children:"Start of line"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"$"})}),(0,s.jsx)(n.td,{children:"End of line"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"\\A"})}),(0,s.jsx)(n.td,{children:"start of string, never the end of line"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"\\Z"})}),(0,s.jsx)(n.td,{children:"end of string, never the end of line"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Line start:"})," Regular expression contains various ",(0,s.jsx)(n.em,{children:"meta-characters"})," such as\n",(0,s.jsx)(n.code,{children:"^"})," in the above example. It means beginning of the line, i.e., ",(0,s.jsx)(n.code,{children:"/^cat/"})," matches\nlines that starts with ",(0,s.jsx)(n.code,{children:"cat"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Line ending:"})," ",(0,s.jsx)(n.code,{children:"$"})," represents the matches at the end of the line. Note that if\nthe line ending is CRLF (",(0,s.jsx)(n.code,{children:"\\r\\n"}),") instead of LF (",(0,s.jsx)(n.code,{children:"\\n"}),"), the unix/Linux grep might\nnot work as expected. Convert the line ending from DOS to Unix:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"dos2unix filename.txt\n\n# if dos2unix is not installed, below is the command for Ubuntu/ Debian\nsudo apt update\nsudo apt install dos2unix\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's say we want to validate a list of email addresses. We assume that valid\nTLD are either 2 or 3 character long (e.g., .in, .com etc.):\n",(0,s.jsx)(n.code,{children:"/^\\w+@\\w+\\.[a-z]{2,3}$/"})]}),"\n",(0,s.jsxs)(n.p,{children:["Line start and line ending might not work as we expect in single line mode, in\norder to enable multiline mode, we may need to add ",(0,s.jsx)(n.code,{children:"m"})," after the regular\nexpression: ",(0,s.jsx)(n.code,{children:"/^\\w+@\\w+\\.[a-z]{2,3}$/mgi"}),", ",(0,s.jsx)(n.code,{children:"g"})," for global, and ",(0,s.jsx)(n.code,{children:"i"})," for case\ninsensitive."]}),"\n",(0,s.jsx)(n.h3,{id:"character-class",children:"Character class"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Character set:"})," ",(0,s.jsx)(n.code,{children:"[ea]"})," can be used to match either ",(0,s.jsx)(n.code,{children:"e"})," or ",(0,s.jsx)(n.code,{children:"a"}),", e.g., to match\ngrey or gray, ",(0,s.jsx)(n.code,{children:"/gr[ea]y/"})," or equivalently, ",(0,s.jsx)(n.code,{children:"/gr[ae]y/"}),", however it will not\nmatch ",(0,s.jsx)(n.code,{children:"great"}),". If we need to find any line starting with ",(0,s.jsx)(n.code,{children:"cat"})," or ",(0,s.jsx)(n.code,{children:"Cat"})," we could\nuse: ",(0,s.jsx)(n.code,{children:"/^[Cc]at/"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Character range:"})," Say we are looking for HTML heading tags, we could use:\n",(0,s.jsx)(n.code,{children:"<h[123456]>"})," it will match either of ",(0,s.jsx)(n.code,{children:"<h1>"}),", ",(0,s.jsx)(n.code,{children:"<h2>"}),", ..., ",(0,s.jsx)(n.code,{children:"<h6>"}),". We could\nsimplify above expression by using range meta-character: ",(0,s.jsx)(n.code,{children:"<h[1-6]>"}),". ",(0,s.jsx)(n.code,{children:"[0-9]"}),"\nmatches any number, ",(0,s.jsx)(n.code,{children:"[a-z]"})," matches any lowercase English letters. We could use\n",(0,s.jsx)(n.code,{children:"31[./-]10[./-]2022"})," to match certain date with any one of the usual separators.\nRange not necessarily can have numeric or uppercase/lowercase, they are the\nASCII character ranges."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Negative character set:"})," in the above example, if we used ",(0,s.jsx)(n.code,{children:"/<h^[7-9]>/"}),", it\nmeans matches that are not ",(0,s.jsx)(n.code,{children:"<h7>"}),", ",(0,s.jsx)(n.code,{children:"<h8>"})," or ",(0,s.jsx)(n.code,{children:"<h9>"}),". Similarly, we could try to\nlook for words that has q followed by another letter that is not u: ",(0,s.jsx)(n.code,{children:"/q[^u]/"}),".\n",(0,s.jsx)(n.code,{children:"/see[^mn]/"}),' will match seek or seed but not seen, seem or see. However, it will\nalso match "see." or "see ". ',(0,s.jsx)(n.code,{children:"/[^a-z0-9A-Z]/"})," will negate all three ranges, not\njust the first one. Notice that ",(0,s.jsx)(n.code,{children:"-"})," is a meta-character inside a character set,\notherwise it is just a regular character. On the other hand ",(0,s.jsx)(n.code,{children:"^"})," has different\nmeanings: inside a character it makes negative character set, otherwise it is a\nanchor for the line beginning. Characters (except, ",(0,s.jsx)(n.code,{children:"]"}),", ",(0,s.jsx)(n.code,{children:"-"}),", ",(0,s.jsx)(n.code,{children:"^"}),", and ",(0,s.jsx)(n.code,{children:"\\"}),")\ninside a character set are regular characters, we do not need to escape them.\nE.g., ",(0,s.jsx)(n.code,{children:"."})," is not a wild card inside character set but a literal dot.\n",(0,s.jsx)(n.code,{children:"/[[(][0-9][)\\]]/"})," will match either a number between parentheses or square\nbrackets. Notice how we needed to escape the closing square bracket. Match\nvirtue but not virtues: ",(0,s.jsx)(n.code,{children:"/virtue[^s\\s]/"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Matching any of several sub-expressions:"})," ",(0,s.jsx)(n.code,{children:"^cat|ion$"})," will match any line\nstarting with cat or ending with ion. ",(0,s.jsx)(n.code,{children:"^cat"})," and ",(0,s.jsx)(n.code,{children:"ion$"})," are separate\nexpressions. In our example of ",(0,s.jsx)(n.code,{children:"gr[ea]y"})," could be written as ",(0,s.jsx)(n.code,{children:"grey|gray"}),". We can\nmatch 1st or First by ",(0,s.jsx)(n.code,{children:"(1|Fir)st"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Case insensitive:"})," We can use the ",(0,s.jsx)(n.code,{children:"-i"})," flag with ",(0,s.jsx)(n.code,{children:"egrep"})," to make our lookup\ncase insensitive."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Shorthand character sets:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Shorthand"}),(0,s.jsx)(n.th,{children:"Meaning"}),(0,s.jsx)(n.th,{children:"Equivalent"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\\d"})}),(0,s.jsx)(n.td,{children:"Digit"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[0-9]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\\w"})}),(0,s.jsx)(n.td,{children:"Word character"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[a-zA-Z0-9_]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\\s"})}),(0,s.jsx)(n.td,{children:"Whitespace"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[\\r\\n\\t]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\\D"})}),(0,s.jsx)(n.td,{children:"Non digit"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[^0-9]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\\W"})}),(0,s.jsx)(n.td,{children:"Non word char"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[^a-zA-Z0-9_]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"\\S"})}),(0,s.jsx)(n.td,{children:"Not whitespace"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[^\\r\\n\\t]"})})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"/\\d\\d\\d\\d/"})," matches 1947, ",(0,s.jsx)(n.code,{children:"/\\w\\w\\w/"})," matches cat, Car, 123, a_1. ",(0,s.jsx)(n.code,{children:"/[\\w\\-]/"}),"\nwill incorporate ",(0,s.jsx)(n.code,{children:"-"})," with the word character. Note that ",(0,s.jsx)(n.code,{children:"/^\\d\\s/"})," is not the\nsame as ",(0,s.jsx)(n.code,{children:"/\\D\\S/"}),", it is same as ",(0,s.jsx)(n.code,{children:"/\\D\\s/"}),". Note that this shorthands might not be\nsupported by all regex engines."]}),"\n",(0,s.jsx)(n.h3,{id:"word-boundaries",children:"Word boundaries"}),"\n",(0,s.jsx)(n.p,{children:"Match any word that starts with cat:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep '\\<cat' A_Room_with_a_View_by_E_M_Forster.txt\n"})}),"\n",(0,s.jsx)(n.p,{children:"Match any word that ends with ion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep 'ion\\>' A_Room_with_a_View_by_E_M_Forster.txt\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Word boundaries will act whenever there is a word character followed by a non-\nword character. Word characters are ",(0,s.jsx)(n.code,{children:"[a-z][A-Z][0-9]_"}),". Any word boundaries is\ndenoted by ",(0,s.jsx)(n.code,{children:"\\b"}),". Find the standalone letter a's: ",(0,s.jsx)(n.code,{children:"/\\ba\\b/"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"optional",children:"Optional"}),"\n",(0,s.jsxs)(n.p,{children:["How to match either color or colour: ",(0,s.jsx)(n.code,{children:"colou?r"}),". July or Jul: ",(0,s.jsx)(n.code,{children:"July?"}),". January or\nJan: ",(0,s.jsx)(n.code,{children:"Jan(uary)?"}),". Note that the expression inside the parenthesis could be more\ncomplex, but here it used for simple grouping for the optional."]}),"\n",(0,s.jsx)(n.h3,{id:"repetition",children:"Repetition"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"Meta-character"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"*"})}),(0,s.jsx)(n.td,{children:"Preceding item zero, or more times"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"+"})}),(0,s.jsx)(n.td,{children:"Preceding item one or more times"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:(0,s.jsx)(n.code,{children:"?"})}),(0,s.jsx)(n.td,{children:"Preceding item one or zero times"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Match ",(0,s.jsx)(n.code,{children:"<h3 size=14>"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep <h3 +size *= *14 *> filename.txt\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"/apples*/"})," will match apple, apples, or applesss. ",(0,s.jsx)(n.code,{children:"/apples+/"})," will match\napples, or applesss but not apple. ",(0,s.jsx)(n.code,{children:"/apples?/"})," will match apple and apples, but\nnot applesss."]}),"\n",(0,s.jsx)(n.p,{children:"Match any size value above:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep <h3 +size *= *[0-9]+ *> filename.txt\n"})}),"\n",(0,s.jsx)(n.p,{children:"Match any tag with or without size attribute:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"egrep <h3( +size *= *[0-9]+)? *> filename.txt\n"})}),"\n",(0,s.jsx)(n.h3,{id:"range-quantifiers",children:"Range quantifiers"}),"\n",(0,s.jsxs)(n.p,{children:["Match 8 to 10 digit numbers: ",(0,s.jsx)(n.code,{children:"[0-9]{8,10}"}),". ",(0,s.jsx)(n.code,{children:"{0,1}"})," is same as ",(0,s.jsx)(n.code,{children:"?"}),"; ",(0,s.jsx)(n.code,{children:"{1,}"})," is\nsame as ",(0,s.jsx)(n.code,{children:"+"}),"; ",(0,s.jsx)(n.code,{children:"{0,}"})," same as ",(0,s.jsx)(n.code,{children:"*"}),". Validate US phone numbers:\n",(0,s.jsx)(n.code,{children:"/\\d{3}-\\d{3}-\\d{4}/"})," matches 234-456-6789."]}),"\n",(0,s.jsx)(n.h3,{id:"grouping",children:"Grouping"}),"\n",(0,s.jsxs)(n.p,{children:["We use ",(0,s.jsx)(n.code,{children:"()"})," to group. ",(0,s.jsx)(n.code,{children:"/(abc)+/"})," will match abc or abcabc or abcabcabc."]}),"\n",(0,s.jsx)(n.h3,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.p,{children:["Online Regex Playground: ",(0,s.jsx)(n.a,{href:"https://regexr.com",children:"https://regexr.com"})]})]})}function o(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},4984:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/files/A_Room_with_a_View_by_E_M_Forster-2fda092ca8540fd6490c64898da1b08a.txt"},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>d});var s=r(6540);const t={},c=s.createContext(t);function i(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);